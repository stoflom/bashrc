
# Load Angular CLI autocompletion.
#:source <(ng completion script)


# Define whence
whence ()
{ 
    local INPUTARG=`/usr/bin/type -ap $1`;
    if [ -x "${INPUTARG}" ]; then
        type -a "$1";
        /usr/bin/ls -al --color=auto "${INPUTARG}";
    else
        type -a "$1";
    fi
}

## Calculate disk usage for all files in the current directory (including hidden files)
dus ()
{
    local dir="${1:-.}" # Use argument 1, or the current directory if no argument is given
    local dotglob_cmd=$(shopt -p dotglob) # save command to reset dotglob
    
    # Enable dotglob: this makes * also match files starting with a dot (hidden files).
    shopt -s dotglob
    
    # Check if we are running in the current directory or a specific one
    if [ "$dir" = "." ]; then
        echo "Calculating disk usage for all files in current directory"
        
        du -hs *
    else
        echo "Calculating disk usage for all files in directory: $dir"
        du -hs "$dir"/*
    fi

    # Restore dotglob to its original state
    $dotglob_cmd
}

# find file in current directory hierarchy
ffile()
{
    # Check if an argument was provided
    if [ -z "$1" ]; then
        echo "Error: Please provide a filename pattern." >&2
        echo "Usage: ffile <pattern>   (a wildcard will be added in front)" >&2
        echo "e.g. ffile IGP0967.* " >&2
        return 1
    fi

    # Execute the find command
    find -L . -name "*${1}"
}

# Define logout for  gnome shell
logout ()
{
 	DISPLAY=:0 gnome-session-quit --force
}


# Function to copy a file with an incrementing number if a file with the same name exists
# this differs from cp --backup=numbered in that the file extension is preserved:
# filename.gpx -> filename#1.gpx etc.

cp-safe() {
  if [ "$#" -ne 2 ]; then
    echo "Usage: cp-safe <source_file> <destination>" >&2
    echo "  <destination> can be a directory or a file path." >&2
    return 1
  fi

  local source_file="$1"
  local dest="$2"
  local dest_dir
  local dest_filename

   # Determine if destination is a directory or a file path
  if [ -d "$dest" ]; then
    # Destination is a directory
    dest_dir="$dest"
    dest_filename=$(basename -- "$source_file")
  else
    # Destination is a file path
    dest_dir=$(dirname -- "$dest")
    dest_filename=$(basename -- "$dest")
  fi

  # Create destination directory if it doesn't exist
  if [ ! -d "$dest_dir" ]; then
    mkdir -p -- "$dest_dir" || { echo "Error: Failed to create directory '$dest_dir'." >&2; return 1; }
  fi

  local filename="$dest_filename"
  local name="${filename%.*}"
  local ext="${filename##*.}"
  
  if [ "$filename" == "$ext" ]; then
    ext=""
  else
    ext=".${ext}"
  fi
  
  local i=0
  local new_filename="${name}${ext}"
  
  # Find the next available number
  while [ -e "${dest_dir}/${new_filename}" ]; do
    i=$((i+1))
    new_filename="${name}#${i}${ext}"
  done
  
  # Copy the file with the new name (verbose)
  cp -v "$source_file" "${dest_dir}/${new_filename}"
}


# Fix less for utf8
export LESSCHARSET=utf-8

# Alias clear
cls ()
{
    clear;
}

# fix fastfetch
ff ()
{
    fastfetch -l none;
}
